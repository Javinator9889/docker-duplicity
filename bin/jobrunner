#!/usr/bin/env python
"""Run all commands extracted from environment variables when they should."""
import os
import re
import sys
from datetime import datetime, timedelta
from os import environ, path
from pathlib import Path
from socket import getfqdn
from string import Template

import cmdutils
from email_client import Email
from logging_utils import get_logger

TMP_JOB_PATH = r"/tmp"
RUNNER_FILE = "jobrunner."

start_time = datetime.now()

log = get_logger()
log.name = "jobrunner"

# Get expected periodicity from this script's placement
periodicity = path.basename(path.dirname(path.abspath(__file__)))
log.info("Running %s jobs", periodicity)

# Check if there is another jobrunning running and another
# waiting. We implement a queue-like system based on files
runners_exists = (
    os.path.exists(f"{TMP_JOB_PATH}/{RUNNER_FILE}.1"),
    os.path.exists(f"{TMP_JOB_PATH}/{RUNNER_FILE}.2"),
)

if all(runners_exists):
    log.warning("Already two runners are enqueued. Exiting...")
    sys.exit(0)
else:
    # prevent any other runner to "join the party"
    ME = 1 if runners_exists[0] else 2
    Path(f"{TMP_JOB_PATH}/{RUNNER_FILE}.{ME}").touch(mode=0o744)

# Get email subject
subject = environ.get("EMAIL_SUBJECT")

# Get the "EXIT_ON_ERROR" variable when running the jobs
exit_on_error = environ.get("EXIT_ON_ERROR", "").lower() in {"1", "true"}

# Get the commands we need to run
to_run = {}
for key, when in environ.items():
    match = re.match(r"^JOB_(\d+)_WHEN$", key)
    if match and periodicity in when.split():
        njob = int(match.group(1))
        to_run[njob] = environ["JOB_{}_WHAT".format(njob)]

if not to_run:
    log.info("Nothing to do")
    sys.exit()


failed = False
job_list = []
for njob, command in sorted(to_run.items()):
    expanded_command = Template(command).safe_substitute(environ)
    job_start = datetime.now()
    safe_command = cmdutils.print_command(expanded_command)
    log.info("Running job %d: `%s`", njob, safe_command)

    # we do not want to use our logger if executing "dup" command as it uses its own logger
    cmd_logger = None if re.match(r"^dup\s+", expanded_command) is not None else log
    ret, res = cmdutils.run(expanded_command, log=cmd_logger)
    if ret != 0:
        log.critical("Failure during execution job!")
        log.critical(res)
        failed = True

    job_end = datetime.now()
    job_list.append(
        {
            "id": njob,
            "start_time": job_start,
            "end_time": job_end,
            "duration": timedelta(microseconds=(job_end - job_start).microseconds),
            "command": safe_command,
            "output": res,
            "status": "Success" if ret == 0 else "Failure",
        }
    )
    if failed and exit_on_error:
        log.critical(
            'Job "%s" failed and user set "EXIT_ON_ERROR" to true. No more jobs will be run'
        )
        break

end_time = datetime.now()
data_dict = {
    "start_time": start_time,
    "finished_time": end_time,
    "duration": timedelta(microseconds=(end_time - start_time).microseconds),
    "jobs": job_list,
    "periodicity": periodicity,
    "hostname": getfqdn(),
    "backup_status": "succeeded" if not failed else "failed",
}

email = Email(
    subject=subject.format(
        hostname=getfqdn(), periodicity=periodicity, result="ERROR" if failed else "OK"
    )
)

email.message = data_dict
email.send()

if failed:
    sys.exit("At least one job failed")
